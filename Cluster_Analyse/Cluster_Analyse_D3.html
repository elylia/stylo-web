<!DOCTYPE html>
<html lang="en">
  <head>
    <script src="package/dist/d3.min.js" charset="utf-8"></script>
    <style>
      html,
      body {
        height: 100%;
        padding: 0;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <script type="text/javascript">
      async function logJSONData() {
        function handleZoom(e) {
          d3.select("g.chart").attr("transform", e.transform);
        }
        let zoom = d3.zoom().on("zoom", handleZoom);

        const response = await fetch("tree_JSON.json");
        const jsonData = await response.json();
        const root = d3.hierarchy(jsonData);

        root.x0 = dy / 2;
        root.y0 = 0;
        root.descendants().forEach((d, i) => {
          d.id = i;
          d._children = d.children;
          console.log(d);
        });

        const svg = d3
          .select("body")
          .append("svg")
          .call(zoom)
          .attr("viewBox", [-margin.left, -margin.top, width, 1000])
          .style("font", "10px sans-serif")
          .style("user-select", "none")
          .style("height", "100%")
          .style("width", "100%");

        const zoomg = svg.append("g").attr("class", "chart");
        var dblclickTarget = svg.on("dblclick.zoom");

        const gLink = zoomg
          .append("g")
          .attr("fill", "none")
          .attr("stroke", "#555")
          .attr("stroke-opacity", 0.4)
          .attr("stroke-width", 1.5);

        const gNode = zoomg
          .append("g")
          .attr("cursor", "pointer")
          .attr("pointer-events", "all");

        function update(source) {
          const duration = d3.event && d3.event.altKey ? 2500 : 250;
          const nodes = root.descendants().reverse();

          const links = root.links();

          // Compute the new tree layout.
          tree(root);

          let left = root;
          let right = root;
          root.eachBefore((node) => {
            if (node.x < left.x) left = node;
            if (node.x > right.x) right = node;
          });
          root.descendants().forEach(function (node) {
            node.y = node.data.height[0] * -1000;
          });
          const height = right.x - left.x + margin.top + margin.bottom;

          const transition = svg
            .transition()
            .duration(duration)
            //.attr("viewBox", [-margin.left, left.x - margin.top, width, height])
            .tween(
              "resize",
              window.ResizeObserver ? null : () => () => svg.dispatch("toggle")
            );

          // Update the nodes…
          const node = gNode.selectAll("g").data(nodes, (d) => d.id);

          // Enter any new nodes at the parent's previous position

          const nodeEnter = node
            .enter()
            .append("g")
            .attr("transform", (d) => `translate(${source.y0},${source.x0})`)
            .attr("fill-opacity", 0)
            .attr("stroke-opacity", 0)
            .on("click", (event, d) => {
              d.children = d.children ? null : d._children;
              update(d);
            });

          nodeEnter
            .append("circle")
            .attr("r", 4)
            .attr("fill", (d) => (d._children ? "#555" : "#999"))
            .attr("stroke-width", 10);

          nodeEnter
            .append("text")
            .attr("dy", "0.31em")
            .attr("x", (d) => (d._children ? -6 : 6))
            .attr("text-anchor", (d) => (d._children ? "end" : "start"))
            .text((d) => d.data.name?.[0])
            .attr("pointer-events", "none")
            .clone(true)
            .lower()
            .attr("stroke-linejoin", "round")
            .attr("stroke-width", 3)
            .attr("stroke", "white");

          // Transition nodes to their new position.
          const nodeUpdate = node
            .merge(nodeEnter)
            .transition(transition)
            .attr("transform", (d) => `translate(${d.y},${d.x})`)
            .attr("fill-opacity", 1)
            .attr("stroke-opacity", 1);

          // Transition exiting nodes to the parent's new position.
          const nodeExit = node
            .exit()
            .transition(transition)
            .remove()
            .attr("transform", (d) => `translate(${source.y},${source.x})`)
            .attr("fill-opacity", 0)
            .attr("stroke-opacity", 0);

          // Update the links…
          const link = gLink.selectAll("path").data(links, (d) => d.target.id);

          // Enter any new links at the parent's previous position.
          const linkEnter = link
            .enter()
            .append("path")
            .attr("d", (d) => {
              return (
                "M" +
                d.source.y +
                "," +
                d.source.x +
                "H" +
                d.target.y +
                "V" +
                d.target.x +
                (d.target.children ? "" : "h" + margin.right)
              );
            });

          // Transition links to their new position.
          link
            .merge(linkEnter)
            .transition(transition)
            .attr("d", (d) => {
              return (
                "M" +
                d.source.y +
                "," +
                d.source.x +
                "H" +
                d.target.y +
                "V" +
                d.target.x +
                (d.target.children ? "" : "h" + margin.right)
              );
            });

          // Transition exiting nodes to the parent's new position.
          link
            .exit()
            .transition(transition)
            .remove()
            .attr("d", (d) => {
              return (
                "M" +
                d.source.y +
                "," +
                d.source.x +
                "H" +
                d.target.y +
                "V" +
                d.target.x +
                (d.target.children ? "" : "h" + margin.right)
              );
            });

          // Stash the old positions for transition.
          root.eachBefore((d) => {
            d.x0 = d.x;
            d.y0 = d.y;
          });
        }

        update(root);

        svg_image = svg.node();

        d3.select("svg").on("dblclick.zoom", null);
      }
      margin = { top: 10, right: 120, bottom: 10, left: 40 };
      width = 500;
      dy = width / 6;
      dx = 50;
      tree = d3.tree().nodeSize([dx, dy]);
      diagonal = d3
        .linkHorizontal()
        .x((d) => d.y)
        .y((d) => d.x);
      logJSONData();
    </script>
  </body>
</html>
